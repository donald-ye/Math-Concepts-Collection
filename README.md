# Math + CS: Numerical Methods Portfolio

This repository is a curated portfolio of five core coding projects that bring together concepts from **applied mathematics**, **numerical computing**, and **algorithm design** â€” implemented from scratch in Python. The goal: to demonstrate both **deep understanding** and **practical execution** of mathematical techniques that underpin scientific computing, graphics, and machine learning.

All work is modular, readable, and built to reflect how a technical contributor thinks, writes, and solves problems â€” from first principles.

---

## ðŸ“Œ Summary of Projects

| Project | Concepts | Skills Showcased |
|--------|----------|------------------|
| **1. Interpolation** | Lagrange, Divided Differences, Cubic Splines | Polynomial construction, continuity handling |
| **2. Fourier & Integration** | Simpson's Rule, Fourier Coefficients, Approximation | Signal reconstruction, integration, convergence |
| **3. Rootfinding** | Bisection, Newton-Raphson, Secant Method | Iterative methods, convergence speed, stability |
| **4. SVD & Compression** | QR Decomposition, Gram-Schmidt, SVD | Dimensionality reduction, image compression | 
| **5. Solving Systems** | Gaussian Elimination, Jacobi, Gauss-Seidel | Matrix ops, precision, iterative solution paths |

> ðŸ’¡ All core techniques are implemented without relying on high-level libraries like `scipy.optimize`, to reinforce mathematical intuition.

---

## ðŸ§ª Why These Projects Matter

These projects represent building blocks of modern numerical software. They're applicable to:

- ðŸ§® Scientific simulations (e.g. physics, climate models)
- ðŸ–¼ Image & signal processing (e.g. compression, noise filtering)
- ðŸ“Š Data science & ML (e.g. dimensionality reduction, function approximation)
- ðŸ’» Systems design (e.g. fast solvers, stability under load)

By writing these methods from the ground up, Iâ€™ve gained hands-on insight into how performance, stability, and numerical error evolve in practice â€” something that directly translates to software engineering rigor.

